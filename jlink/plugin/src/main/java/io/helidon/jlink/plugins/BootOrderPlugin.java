/*
 * Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.helidon.jlink.plugins;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import io.helidon.jlink.logging.Log;

import jdk.tools.jlink.plugin.Plugin;
import jdk.tools.jlink.plugin.PluginException;
import jdk.tools.jlink.plugin.ResourcePool;
import jdk.tools.jlink.plugin.ResourcePoolBuilder;
import jdk.tools.jlink.plugin.ResourcePoolEntry;

import static java.util.stream.Collectors.toList;

/**
 * A sorter that puts the boot classes, in order, first. This ordering shouldn't matter when
 * we run with a CDS archive that contains all of the boot classes, but will if the archive
 * isn't used.
 */
public class BootOrderPlugin implements Plugin {
    public static final String NAME = "boot-order";
    private static final Log LOG = Log.getLog(NAME);
    private static final String JAVA_BASE = "java.base";
    private static final String JAVA_BASE_PREFIX = "/" + JAVA_BASE + "/";
    private static final String SYSTEM_MODULES_PATH_PREFIX = JAVA_BASE_PREFIX + "jdk/internal/module/SystemModules";
    private static final String SYSTEM_MODULE_FINDERS_PATH = "jdk/internal/module/SystemModuleFinders.class";
    private static final String CLASS_SUFFIX = ".class";

    @Override
    public String getName() {
        return NAME;
    }

    @Override
    public boolean hasArguments() {
        return false;
    }

    @Override
    public Category getType() {
        return Category.SORTER;
    }

    @Override
    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {
        LOG.info("Sorting by application boot class order");
        final ApplicationContext context = ApplicationContext.get();
        final List<String> bootClassList = context.classList().stream().map(n -> n + CLASS_SUFFIX).collect(toList());
        final Set<String> bootClassSet = new HashSet<>(bootClassList);

        // The class list was generated by starting the application from jars, and may not be exactly the same
        // as it would be if we generated it from the final image. That isn't a choice here, since we're still
        // building it. One important potential difference is the set of SystemModules* classes generated by the
        // BootModulesPlugin, and we want to make sure we add any missing ones here...
        //
        // Insert any missing SystemModules* classes into the list right after the system module finders class

        final int findersIndex = bootClassList.indexOf(SYSTEM_MODULE_FINDERS_PATH);
        if (findersIndex >= 0) {
            final List<String> systemModules = in.moduleView()
                                                 .findModule(JAVA_BASE)
                                                 .orElseThrow()
                                                 .entries()
                                                 .filter(entry -> entry.path().endsWith(CLASS_SUFFIX))
                                                 .filter(entry -> entry.path().startsWith(SYSTEM_MODULES_PATH_PREFIX))
                                                 .map(entry -> {
                                                     final String path = entry.path();
                                                     return path.substring(JAVA_BASE_PREFIX.length());
                                                 })
                                                 .filter(entry -> !bootClassSet.contains(entry)) // Could already be there
                                                 .collect(toList());
            if (!systemModules.isEmpty()) {
                bootClassList.addAll(findersIndex + 1, systemModules);
                bootClassSet.addAll(systemModules);
            }
        } else {
            throw new PluginException("Did not find " + SYSTEM_MODULE_FINDERS_PATH + " in class list");
        }

        // Copy the boot classes first, remembering what we copied. This search assumes that the first module that
        // contains the class is the one we want, but it could possibly be in another module; if that occurs, we
        // just won't be optimized as much as possible.

        final Map<String, ResourcePoolEntry> bootEntries = new HashMap<>();
        in.entries().forEach(entry -> {
            final String modulePath = entry.path();
            final int secondSlash = modulePath.indexOf('/', 1);
            final String path = modulePath.substring(secondSlash + 1);
            if (bootClassSet.contains(path)) {
                if (!bootEntries.containsKey(path)) {
                    bootEntries.put(path, entry);
                }
            }
        });

        final Set<String> copied = new HashSet<>();
        bootClassList.forEach(path -> {
            final ResourcePoolEntry entry = bootEntries.get(path);
            if (entry == null) {
                LOG.debug("Did not find boot class %s in entries", path);
            } else {
                out.add(entry);
                copied.add(entry.path());
            }
        });

        // Copy the remaining entries

        in.entries()
          .filter(entry -> !copied.contains(entry.path()))
          .forEach(out::add);

        return out.build();
    }
}
